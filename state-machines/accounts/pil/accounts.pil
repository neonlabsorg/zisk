require "std_lookup.pil"
require "std_permutation.pil"

const int ACCOUNTS_INIT_BUS_ID = 7891;
const int ACCOUNTS_RESULT_BUS_ID = 7892;
const int POSEIDON_PERMUTER = 7893;
const int POSEIDON_WIDTH = 12;

public accounts_init[4];
public accounts_result[4];

airtemplate PoseidonPermuter(int N = 2**21, const int bus_id = POSEIDON_PERMUTER, const int partial_rounds = 57, const int full_rounds = 12) {
    const int rounds = partial_rounds + full_rounds * 2;
    col witness state[POSEIDON_WIDTH];
    col witness round;

    col witness last_round;
    last_round * (1 - last_round) === 0;
    last_round * (round + 1 - rounds) === 0;

    col witness first_round;
    col fixed L1 = [1,0...];
    L1*(first_round - 1) === 0;
    first_round * (1 - first_round) === 0;
    round * first_round === 0;

    round === ('round + 1) * (1 - first_round);

    col witness input[POSEIDON_WIDTH];
    for (int i = 0; i < POSEIDON_WIDTH; ++i) {
        (1 - first_round) * (input[i] - 'input[i]) === 0;
    }

    col witness full_round;
    expr partial_round = 1 - full_round;
    full_round * partial_round === 0;
    (1 - first_round) * (full_round - 'full_round) * (round - full_rounds) * (round - full_rounds - partial_rounds) === 0;

    // the first and last are full ones
    last_round * (full_round - 1) === 0;
    first_round * (full_round - 1) === 0;

    const int arc[POSEIDON_WIDTH] = [
                3014888795719246729,
                5963864597674384598,
                2768803421146185923,
                18185368981409310590,
                13796279610465360307,
                13258428655399477418,
                6311108545355074403,
                9091478136808910551,
                5657164823329005273,
                14773843000339061443,
                5277400092504871362,
                6244933830025130194
            ];
    col witness b[POSEIDON_WIDTH];
    for (int i = 0; i < POSEIDON_WIDTH; ++i) {
        b[i] === (1-first_round)*'state[i] + arc[i];
    }

    col witness c[POSEIDON_WIDTH];
    for (int i = 0; i < POSEIDON_WIDTH; ++i) {
        expr b7 = b[i] * b[i] * b[i] * b[i] * b[i] * b[i] * b[i];
        if (i == 0) {
            c[i] === b7;
        } else {
            c[i] === (1 - partial_round) * (b7 - b[i]) + b[i];
        }
    }

    col witness d[POSEIDON_WIDTH];
    d[0] === 25*c[0] + 15*c[1] + 41*c[2] + 16*c[3] +  2*c[4] + 28*c[5] + 13*c[6] + 13*c[7] + 39*c[8] + 18*c[9] + 34*c[10] + 20*c[11];
    d[1] === 20*c[0] + 17*c[1] + 15*c[2] + 41*c[3] + 16*c[4] +  2*c[5] + 28*c[6] + 13*c[7] + 13*c[8] + 39*c[9] + 18*c[10] + 34*c[11];
    d[2] === 34*c[0] + 20*c[1] + 17*c[2] + 15*c[3] + 41*c[4] + 16*c[5] +  2*c[6] + 28*c[7] + 13*c[8] + 13*c[9] + 39*c[10] + 18*c[11];
    d[3] === 18*c[0] + 34*c[1] + 20*c[2] + 17*c[3] + 15*c[4] + 41*c[5] + 16*c[6] +  2*c[7] + 28*c[8] + 13*c[9] + 13*c[10] + 39*c[11];
    d[4] === 39*c[0] + 18*c[1] + 34*c[2] + 20*c[3] + 17*c[4] + 15*c[5] + 41*c[6] + 16*c[7] +  2*c[8] + 28*c[9] + 13*c[10] + 13*c[11];
    d[5] === 13*c[0] + 39*c[1] + 18*c[2] + 34*c[3] + 20*c[4] + 17*c[5] + 15*c[6] + 41*c[7] + 16*c[8] +  2*c[9] + 28*c[10] + 13*c[11];
    d[6] === 13*c[0] + 13*c[1] + 39*c[2] + 18*c[3] + 34*c[4] + 20*c[5] + 17*c[6] + 15*c[7] + 41*c[8] + 16*c[9] +  2*c[10] + 28*c[11];
    d[7] === 28*c[0] + 13*c[1] + 13*c[2] + 39*c[3] + 18*c[4] + 34*c[5] + 20*c[6] + 17*c[7] + 15*c[8] + 41*c[9] + 16*c[10] +  2*c[11];
    d[8] ===  2*c[0] + 28*c[1] + 13*c[2] + 13*c[3] + 39*c[4] + 18*c[5] + 34*c[6] + 20*c[7] + 17*c[8] + 15*c[9] + 41*c[10] + 16*c[11];
    d[9] === 16*c[0] +  2*c[1] + 28*c[2] + 13*c[3] + 13*c[4] + 39*c[5] + 18*c[6] + 34*c[7] + 20*c[8] + 17*c[9] + 15*c[10] + 41*c[11];
    d[10] === 41*c[0] + 16*c[1] +  2*c[2] + 28*c[3] + 13*c[4] + 13*c[5] + 39*c[6] + 18*c[7] + 34*c[8] + 20*c[9] + 17*c[10] + 15*c[11];
    d[11] === 15*c[0] + 41*c[1] + 16*c[2] +  2*c[3] + 28*c[4] + 13*c[5] + 13*c[6] + 39*c[7] + 18*c[8] + 34*c[9] + 20*c[10] + 17*c[11];

    for (int i = 0; i < POSEIDON_WIDTH; ++i) {
        (state[i] - d[i]) * (1 - first_round) === 0;
        (state[i] - input[i]) * first_round === 0;
    }

    permutation_proves(bus_id, [...input, ...state], sel: last_round);
}

airtemplate AccountsInit(int N = 2**21, const int bus_id = ACCOUNTS_INIT_BUS_ID, const int result_bus_id = ACCOUNTS_RESULT_BUS_ID, const int RC=2, const int poseidon_id = POSEIDON_PERMUTER) {
    col witness addr;
    col witness val[RC];

    col witness multiplicity;

    col witness sel;
    sel * (1 - sel) === 0;

    lookup_proves(bus_id, [addr, ...val], mul: multiplicity);
    permutation_assumes(result_bus_id, [addr, ...val], sel: sel);

    col fixed L1 = [1,0...];
    col witness hash_accum[POSEIDON_WIDTH];
    expr hash_input[POSEIDON_WIDTH];
    for (int i = 0; i < POSEIDON_WIDTH; ++i) {
        hash_input[i] = (1 - L1) * 'hash_accum[i];
    }
    hash_input[0] += addr;
    hash_input[1] += val[0];
    hash_input[2] += val[1];
    permutation_assumes(poseidon_id, [...hash_input, ...hash_accum], sel: sel);
    for (int i = 0; i < POSEIDON_WIDTH; ++i) {
        (1 - sel) * (hash_accum[i] - 'hash_accum[i]) === 0
    }
    for (int i = 0; i < 4; ++i) {
        L1' * (hash_accum[i] - accounts_init[i]) === 0;
    }
}

airtemplate AccountsResult(int N = 2**21, const int bus_id = ACCOUNTS_RESULT_BUS_ID, const int RC=2, const int poseidon_id = POSEIDON_PERMUTER) {
    col witness addr;
    col witness val[RC];

    col witness val_init[RC];

    col witness val_wr[RC];
    col witness sel_wr;

    col witness sel;
    sel * (1 - sel) === 0;

    (1 - sel_wr) * sel_wr === 0;

    for (int i = 0; i < RC; i++) {
        (val[i] - val_wr[i]) * sel_wr === 0;
        (val[i] - val_init[i]) * (1 - sel_wr) === 0;
    }

    permutation_proves(bus_id, [addr, ...val_wr], sel: sel_wr*sel);
    permutation_proves(bus_id, [addr, ...val_init], sel: sel);

    col fixed L1 = [1,0...];
    col witness hash_accum[POSEIDON_WIDTH];
    expr hash_input[POSEIDON_WIDTH];
    for (int i = 0; i < POSEIDON_WIDTH; ++i) {
        hash_input[i] = (1 - L1) * 'hash_accum[i];
    }
    hash_input[0] += addr;
    hash_input[1] += val[0];
    hash_input[2] += val[1];
    permutation_assumes(poseidon_id, [...hash_input, ...hash_accum], sel: sel);
    for (int i = 0; i < POSEIDON_WIDTH; ++i) {
        (1 - sel) * (hash_accum[i] - 'hash_accum[i]) === 0
    }
    for (int i = 0; i < 4; ++i) {
        L1' * (hash_accum[i] - accounts_result[i]) === 0;
    }
}
